题解也是笔记
题意
考虑一个长度为n的数列 a1,a2,a3...an，计算所有子序列的权值之和，
对于一个序列的权值，采用如下的方法计算：
1，每次选择一个数，然后删掉它，并且把剩余的数都加上删掉的这个数的大小。
2，最后剩余的数就是答案，多种删除方法中，取使得最后剩余的数最大的删除方案。

一开始我们先尝试模拟一下这个过程，简单地证明了单个序列中每次删最大的那个肯定最后的值肯定最大
下面给出严格证明的过程:
  令一个长度为m的子序列{b1,b2,b3..bn} 如果我们从后往前面删，最后的答案为
S = b1+Σ(i=2,i<=m)bi*2^(i-2) 就是大的越放后S的值就越大

贡献法的开端：
当知道每次删最大的值时是最好的情况了,那么一个序列的子序列里的元素，他们的顺序就不会影响答案了
所以我们先把原数组{an}从小到大排个序。根据题目给的数据范围，枚举每一个子序列是复杂度是非常大的，
所以我们想到求{an}中每一个项 ak 他的总贡献值，最后在把每一个项的贡献值加起来就行了。

贡献法的推导与二项式定理的妙用：
对于项 ak 我们能知道有 k-1 个项是比他小的 n-k 个项是比他大的 假设在每一个合适的子序列里 ak 的
大小排名为 i 那么对于 ak 对于每一个子序列的"贡献次数"(其实也是构成子序列的个数)就是为(k-1,i-1)*2^n-k ('括号是组合数')
另外，排名为 i 的值对于单个子序列的贡献值为ci*ak,
{ci}中分为两部分,第一部分是 c1=1,c2=2。令一部分为 ci=2^(i-3),i>=3
所以对与单个ak的贡献值就为 Sk = Σ(i=1,k)*ci*(k-1,i-1) 
因为 2(n-k) 和 ak 这两个项并不受i影响 所以这个项可以放到最后再乘

二项式定理:
(x+y)^k=Σ(i=0,k)x^i*y^k-i 根据这个从左边往右边推导，也可以把其中一项换成常数(如1、0等等)

最后求得 第k项的贡献值为 ak*2(n-1)*(3^k-1+1)/2 来个for循环就搞定了